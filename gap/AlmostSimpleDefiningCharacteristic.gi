# TODO: In some functions we choose particular elements of the generating set.
#       We have to check whether the group generated by these elements is equal to the group
#       generated in magma (Or have some other kind of check whether the output is correct).
#       Write functions which output the generators for the functions below?
#       Talk with Sergio about this



####################################################################################
############################# OverSmallerField #####################################
####################################################################################


# The following functions are from the Recog Package.
# Since some functions call other functions from the Recog Package, one
# needs to load the Recog Package.


# From the Recog Package but slightly modified (by DR).
# "write over a smaller field with same degree",
ReduceOverSmallerField := function(ri, G)
    # We assume G to be absolutely irreducible, although this is not
    # necessary:
    local Gprime,H,b,dim,f,hom,mo,newgens,pf,r;
    RECOG.SetPseudoRandomStamp(G,"Subfield");
    f := ri!.field;
    if IsPrimeField(f) then
        return NeverApplicable;     # nothing to do
    elif not IsBound(ri!.meataxemodule) then
        ri!.meataxemodule := GModuleByMats(GeneratorsOfGroup(G),f);
    fi;
    if not MTX.IsIrreducible(ri!.meataxemodule) then
        return NeverApplicable;     # not our case
    fi;
    dim := ri!.dimension;
    pf := PrimeField(f);
    b := RECOG.BaseChangeForSmallestPossibleField(G,ri!.meataxemodule,f);
    if b <> fail then
        Info(InfoRecog, 2, StringFormatted(
             "Conjugating group from GL({},{}) into GL({},{}).",
             dim, f, dim, b.field));
        # Do base change isomorphism:
        H := GroupWithGenerators(b.newgens);
        hom := GroupHomByFuncWithData(G,H,RECOG.HomDoBaseAndFieldChange,b);
        SetIsInjective(hom,true);
        SetIsSurjective(hom,true);
        # Now report back, it is an isomorphism:
        SetHomom(ri,hom);
        findgensNmeth(ri).method := FindKernelDoNothing;
        return H;
    fi;

    # nothing more to do for us, C3C5 takes care of the rest!
    return NeverApplicable;
end;



OverSmallerField := function(T,G)
    local ri;

    ri := EmptyRecognitionInfoRecord(T,G,true);
    return ReduceOverSmallerField(ri,G);

end;



####################################################################################
############################# SL2, GU2, GL2 ########################################
####################################################################################


# Find a replacment in GAP for the following functions:
# * SL2, GU2, GL2 can be found in "gl2.m"

# TODO
GL2 := function(n,q)

end;


# TODO
SL2 := function(n,q)

end;


#TODO
GU2 := function(n,q)

end;


# TODO
SU2 := function(n,q)

end;


####################################################################################
#################################### Step 2 ########################################
####################################################################################

# Functions got replaced as follows
# * GModule -> GModuleByMats(mats,fld)
# * TensorProduct -> TensorProductGModule
# * Filtered(Constituents(T),c->DimensionOfMatrixGroup(c)=i)[1]; ->
#   Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = i)[1];
# * SubStructure(GL(2,q),SL(2,q),#TODO CLOSURE DiagonalMat(GF(q),[w,1])); ->
#   Group(Concatenation(GeneratorsOfGroup(A),[S]));
# * A := A^TransformForm(A); -> A := ConjugateToStandardForm(A,type)
# * A:=ActionGroup(MM); -> A := Group(MTX.Generators(MM));
# * ModToQ -> ConjugateModule(M,q) [M module, q power]
# * IsOverSmallerField -> OverSmallerField (Recog Package, Solved by Anna and me) [see above]


# TODO
BindGlobal("ConstructDefiningCharacteristicRepresentationOfAlmostSimpleGroup",
function(q)
    # TODO
end);


BindGlobal("ComputeActionGroupOfConstitutionsByDim",
function(G,fld,dim)
    local M, T, MM, A;
    
    M:=GModuleByMats(GeneratorsOfGroup(G), fld);
    T:=TensorProductGModule(M,M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = dim)[1];
    A := Group(MTX.Generators(MM));
    
    return A;
end);


# Construction of group as in Table 5.6 row 4 from [BHR13]
BindGlobal("l3qdim6",
function(q, general)
    local A, G, M, MM, S, T, w;
    Assert(1,IsOddInt(q));
    w := PrimitiveElement(GF(q));
    # rewritten select statement
    if general then
        G := GL(3,q);
    else
        G := SL(3,q);
    fi;
    M := GModuleByMats(GeneratorsOfGroup(G),GF(q));
    T := TensorProductGModule(M,M);
    MM := Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c)=6)[1];
    if not general then
        S := w^(QuoInt((q-1),Gcd(6,q-1)))*IdentityMat(6,GF(q));
    else
        S := w*IdentityMat(6,GF(q));
    fi;
    return Group(Concatenation(MTX.Generators(MM),[S]));
end);


# Construction of group as in Table 5.6 row 5 from [BHR13]
BindGlobal("u3qdim6",
function(q, general, normaliser)
    local A, G, M, MM, S, T, w;
    Assert(1,IsOddInt(q));
    if normaliser then
        general := true;
    fi;
    w := PrimitiveElement(GF(q^2));
    # rewritten select statement
    if general then
        G := GU(3,q);
    else
        G := SU(3,q);
    fi;
    M := GModuleByMats(GeneratorsOfGroup(G),GF(q^2));
    T := TensorProductGModule(M,M);
    MM := Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 6)[1];
    A := Group(MTX.Generators(MM));
    # change back fixed form into standard GAP form Antidiag(1, ..., 1)
    # SetInvariantSesquilinearForm(A, rec(matrix := Unitary(A)));
    A := ConjugateToStandardForm(A, "U");
    if not general then
        S := (w^(q-1))^(QuoInt((q+1),Gcd(6,q+1)))*IdentityMat(6,GF(q^2));
    elif not normaliser then
        S := w^(q-1)*IdentityMat(6,GF(q^2));
    else 
        S := w*IdentityMat(6,GF(q^2));
    fi;
    
    return Group(Concatenation(GeneratorsOfGroup(A),[S]));
end);


BindGlobal("OrthogSL2",
function(d,q,special,general,normaliser)
    #  /out: construct SL(2,q) in O(d,q) for d odd
    local A,G,M,MM,S,T,i,w;
    Assert(1,IsOddInt(d));
    Assert(1,IsOddInt(q));
    #   construct GL(2,q) as SL(2,q) with extra generator
    w:=PrimitiveElement(GF(q));
    G:=Group(Concatenation(GeneratorsOfGroup(SL(2,q)),[DiagonalMat([w,1])]));
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q));
    MM:=M;
    for i in [3..d] do
        T:=TensorProductGModule(M,MM);
        MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = i)[1];
    od;
    A:=Group(MTX.Generators(MM));
    S:=w^(QuoInt((d-1),2))*IdentityMat(d,GF(q));
    A:=GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2],GeneratorsOfGroup(A)[3]*S^(-1)]);
    Assert(1,DeterminantMat(GeneratorsOfGroup(A)[3])= 1 * One(GF(q)));
    # TODO: Translate next line into GAP code
    # Assert(1,SymmetricBilinearForm(A));
    # TODO: Type of ConjugateToStandardForm maybe "O"?
    A:=A^ConjugateToStandardForm(A,"S");
    if normaliser then
        return GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2],GeneratorsOfGroup(A)[3],w*IdentityMat(d,GF(q))]);
    elif general then
        return GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2],GeneratorsOfGroup(A)[3],(-1)*IdentityMat(d,GF(q))]);
    elif special or (GeneratorsOfGroup(A)[3] in Omega(0,d,q)) then
        #  InOmega(A.3,d,q,0) seems to happen for d = 1 or 7 mod 8.
        return A;
    else
        return GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2]]);
    fi;
end);


BindGlobal("SymplecticSL2",
function(d,q,normaliser)
    #  /out: construct SL(2,q) in Sp(d,q) for d even
    local A,DA,G,M,MM,S,T,form,i,isit,tmat,w,MDA;
    Assert(1,IsEvenInt(d));
    Assert(1,IsOddInt(q));
    #   construct GL(2,q) as SL(2,q) with extra generator
    w:=PrimitiveElement(GF(q));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(2,q)), [DiagonalMat([w,1])]));
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q));
    MM:=M;
    for i in [3..d] do
        T:=TensorProductGModule(M,MM);
        MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = i)[1];
    od;
    A:=Group(MTX.Generators(MM));
    S:=w^(QuoInt((d-2),2))*IdentityMat(d,GF(q));
    A:=GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2],GeneratorsOfGroup(A)[3]*S^(-1)]);
    DA:=GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2]]);
    # =v= MULTIASSIGN =v=
    # form:=SymplecticForm@(DA);
    # isit:=form.val1;
    # form:=form.val2;
    # =^= MULTIASSIGN =^=
    # Assert(1,isit);
    # tmat:=TransformForm(form,"symplectic");
    tmat := ConjugateToStandardForm(DA,"S");
    A:=A^tmat;
    if normaliser then
        return A;
    else
        return GroupByGenerators([GeneratorsOfGroup(A)[1],GeneratorsOfGroup(A)[2]]);
    fi;
end);


BindGlobal("l5qdim10",
function(q,general)
    local A,G,M,MM,S,T,w;
    w:=PrimitiveElement(GF(q));
    # rewritten select statement
    if general then
        G:=GL(5,q);
    else
        G:=SL(5,q);
    fi;
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q));
    T:=TensorProductGModule(M,M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    A:=Group(MTX.Generators(MM));
    if not general then
        S:=w^(QuoInt((q-1),Gcd(10,q-1)))*IdentityMat(10,GF(q));
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(A),[S]));
    fi;
    return GroupByGenerators(Concatenation(GeneratorsOfGroup(A),[w*IdentityMat(10,GF(q))]));
end);


BindGlobal("u5qdim10",
function(q,general,normaliser)
    local A,G,M,MM,S,T,w;
    if normaliser then
        general:=true;
    fi;
    w:=PrimitiveElement(GF(q^2));
    # rewritten select statement
    if general then
        G:=GU(5,q);
    else
        G:=SU(5,q);
    fi;
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q^2));
    T:=TensorProductGModule(M,M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    A:=Group(MTX.Generators(MM));
    A:=ConjugateToStandardForm(A, "U");
    if not general then
        S:=(w^(q-1))^(QuoInt((q+1),Gcd(10,q+1)))*IdentityMat(10,GF(q^2));
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(A),[S]));
    fi;
    if not normaliser then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(A),[w^(q-1)*IdentityMat(10,GF(q^2))]));
    fi;
    return GroupByGenerators(Concatenation(GeneratorsOfGroup(A),[w*IdentityMat(10,GF(q^2))]));
end);


BindGlobal("l2q3dim8",
function(q,normaliser)
    #  /out:SL(2,q^3).3 <= Sp(8,q);
    local G,M,M1,M2,T,varX,iso,u,w,GG;
    w:=PrimitiveElement(GF(q^3));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(2,q^3)),[DiagonalMat([w,One(GF(q^3))])]));
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q^3));
    M1:=ConjugateModule(M,q);
    M2:=ConjugateModule(M1,q);
    T:=TensorProductGModule(M,TensorProductGModule(M1,M2));
    Assert(1,MTX.IsIrreducible(T));
    u:=PermutationMat((2,3,5)(4,7,6),8,GF(q^3));
    #  induces field automorphism
    varX:= GroupByGenerators(Concatenation(MTX.Generators(T),[u]));
    G:=OverSmallerField(GModuleByMats(GeneratorsOfGroup(varX),GF(q^3)),varX);
    # MAGMA G:=G^TransformForm(SubStructure(G,G.1,G.2));
    # Write a function to realise this in GAP
    GG := GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2]]);
    G:=ConjugateToStandardForm(G,"L");
    ########
    if normaliser then
        return G;
    fi;
    return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],GeneratorsOfGroup(G)[4]]);
end);


BindGlobal("l3qdim8",
function(q, special, general, normaliser)
    #  /out:SL(3,q)(.3) <= O+(8,q), q mod 3 = 1 or O-(8,q), q mod 3 = 2
    local C,G,G8,M,M8,T,w;
    w:=PrimitiveElement(GF(q));
    G:=GL2(3,q);
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q));
    T:=TensorProductGModule(M,M);
    M8:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 8)[1];
    G8:=Group(MTX.Generators(M8));
    G8:=ConjugateToStandardForm(G8, "S");
    if normaliser then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G8),[w*IdentityMat(8,GF(q))]));
    elif general and IsOddInt(q) then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G8),[-1*IdentityMat(8,GF(q))]));
    elif (special or general) and IsEvenInt(q) then
        return G8;
    elif special or q mod 3=1 then
        return GroupByGenerators([GeneratorsOfGroup(G8)[1],GeneratorsOfGroup(G8)[2],-1*IdentityMat(8,GF(q))]);
    else
        return GroupByGenerators([GeneratorsOfGroup(G8)[1],GeneratorsOfGroup(G8)[2]]);
    fi;
end);


BindGlobal("u3qdim8",
function(q,special,general,normaliser)
    #  /out:SU(3,q)(.3) <= O+(8,q), q mod 3 = 2 or O-(8,q), q mod 3 = 1
    local C,G,G8,G8q,M,M8,T,isit,w;
    w:=PrimitiveElement(GF(q));
    G:=GU2(3,q);
    G8 := ComputeActionGroupOfConstitutionsByDim(G,GF(q),8);
    G8q:=OverSmallerField(GModuleByMats(GeneratorsOfGroup(G),GF(q)),G8);
    G8q:=ConjugateToStandardForm(G8q,"U");
    if normaliser then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G8q),[w*IdentityMat(8,GF(q))]));
    elif general and IsOddInt(q) then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G8q),[-1*IdentityMat(8,GF(q))]));
    elif (special or general) and IsEvenInt(q) then
        return G8q;
    elif special or q mod 3=2 then
        return GroupByGenerators([GeneratorsOfGroup(G8q)[1],GeneratorsOfGroup(G8q)[2],-1*IdentityMat(8,GF(q))]);
    else
        return GroupByGenerators([GeneratorsOfGroup(G8q)[1],GeneratorsOfGroup(G8q)[2]]);
    fi;
end);


BindGlobal("l2q2dim9",
function(q,special,general,normaliser)
    #  /out:L(2,q^2).2 <= O(9,q);
    local C,G,M,M1,T,varX,form,g3,g4,gg,isit,iso,rt,scal,tform,u,w,z,MG;
    w:=PrimitiveElement(GF(q^2));
    z:=w^(q+1);
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(2,q^2)),[One(GF(q^2))* DiagonalMat([w,1])]));
    M:=GModuleByMats(G,GF(q^2));
    M1:=ConjugateModule(M,q);
    T:=TensorProductGModule(M,M1);
    Assert(1,IsIrreducible(T));
    u:=PermutationMat((2,3),4,GF(q^2));
    #  induces field automorphism
    varX:=GroupByGenerators(Concatenation(MTX.Generators(T),[u]));
    G:=OverSmallerField(GModuleByMats(Concatenation(MTX.Generators(T),[u]),GF(q^2)),varX);
    M:=GModuleByMats(GeneratorsOfGroup(G),GF(q^2));
    T:=TensorProductGModule(M,M);
    C:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 9)[1];
    G:=Group(MTX.Generators(C));
    
    # MAGMA     G:=G^TransformForm(SubStructure(G,G.1,G.2));
    # Write a function to realise this in GAP
    MG := GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2]]);
    G:=ConjugateToStandardForm(G,"L");
    
    # TODO: How to do this in GAP?
    #  adjust G.3 to fix form and G.4 to have determinant 1
    # =v= MULTIASSIGN =v=
    # form:=SymmetricBilinearForm(SubStructure(G,G.1,#TODO CLOSURE G.2));
    # isit:=form.val1;
    # form:=form.val2;
    # =^= MULTIASSIGN =^=
    # tform:=G.3*form*TransposedMat(G.3);
    # scal:=form[1][9]/tform[1][9];
    # =v= MULTIASSIGN =v=
    # rt:=IsPower(scal,2);
    # isit:=rt.val1;
    # rt:=rt.val2;
    # =^= MULTIASSIGN =^=
    # Assert(1,isit);
    # g3:=G.3*ScalarMat(9,rt);
    # rewritten select statement
    
    g3 := GeneratorsOfGroup(G)[3];
    if DeterminantMat(g3)=1 then
        g3:=g3;
    else
        g3:=-g3;
    fi;
    # rewritten select statement
    if DeterminantMat(GeneratorsOfGroup(G)[4])=1 then
        g4:=GeneratorsOfGroup(G)[4];
    else
        g4:=-GeneratorsOfGroup(G)[4];
    fi;
    G:=GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3,g4]);
    if normaliser then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G),[z*IdentityMat(9,GF(q))]));
    elif general then
        return GroupByGenerators(Concatenation(GeneratorsOfGroup(G),[-1*IdentityMat(9,GF(q))]));
    elif special then
        return G;
    else
        # rewritten select statement
        if g3 in Omega(0,9,q) then
            gg:=g3;
        else
            # rewritten select statement
            if g4 in Omega(0,9,q) then
                gg:=g4;
            else
                gg:=g3*g4;
            fi;
        fi;
        return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],gg]);
    fi;
end);


BindGlobal("l3q2dim9l",
function(q,general)
    #  /out:(3.)L(3,q^2)(.3).2 <= L(9,q)
    local G,M,M1,T,varX,g4,iso,u,w,z,g3;
    w:=PrimitiveElement(GF(q^2));
    z:=w^(q+1);
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(3,q^2)),[One(GF(q^2))* DiagonalMat([w,1,1])]));
    M:=GModuleByMats(G,GF(q^2));
    M1:=ConjugateModule(M,q);
    T:=TensorProductGModule(M,M1);
    Assert(1,IsIrreducible(T));
    u:=PermutationMat((2,4)(3,7)(6,8),9,GF(q^2));
    #  induces field automorphism
    varX:=GroupByGenerators(Concatenation(MTX.Generators(T),[u]));
    G:=OverSmallerField(GModuleByMats(Concatenation(MTX.Generators(T),[u]),GF(q^2)),varX);
    #  adjust G.4 to have determinant 1
    # rewritten select statement
    if DeterminantMat(GeneratorsOfGroup(G)[4])=1 then
        g4:=GeneratorsOfGroup(G)[4];
    else
        g4:=-GeneratorsOfGroup(G)[4];
    fi;
    G:=GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],GeneratorsOfGroup(G)[3],g4]);
    if general then
        return Group(Concatenation(GeneratorsOfGroup(G),[z*IdentityMat(9,GF(q))]));
    else
        #  get power of G.3 with determinant 1
        g3 := GeneratorsOfGroup(G)[3];
        return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3^DeterminantMat(g3),g4]);
    fi;
end);


BindGlobal("l3q2dim9u",
function(q,general,normaliser)
    #  /out:(3.)L(3,q^2)(.3).2 <= L(9,q)
    local G,M,M1,T,g4,u,w,z, MG, gens;
    w:=PrimitiveElement(GF(q^2));
    z:=w^(q-1);
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(3,q^2)),[One(GF(q^2))* DiagonalMat([w,1,1])]));
    M:=GModuleByMats(G,GF(q^2));
    M1:=ConjugateModule(M,q);
    # Dual(M)?
    T:=TensorProductGModule(DualGModule(M),M1);
    Assert(1,IsIrreducible(T));
    u:=PermutationMat((2,4)(3,7)(6,8),9,GF(q^2));
    #  induces field automorphism
    G:=GroupByGenerators(Concatenation(MTX.Generators(T),[u]));
    # Magma   G:=G^TransformForm(SubStructure(G,G.1,#TODO CLOSURE G.2));
    # Write a function to realise this in GAP
    MG := GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2]]);
    G:=ConjugateToStandardForm(G,"L");
  
    #  adjust G.4 to have determinant 1
    # rewritten select statement
    if DeterminantMat(GeneratorsOfGroup(G)[4])=1 then
        g4:=GeneratorsOfGroup(G)[4];
    else
        g4:=-GeneratorsOfGroup(G)[4];
    fi;
    G:=GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],GeneratorsOfGroup(G)[3],g4]);
    if normaliser then
        return Group(Concatenation(GeneratorsOfGroup(G),[w*IdentityMat(9,GF(q))]));
    elif general then
        return Group(Concatenation(GeneratorsOfGroup(G),[z*IdentityMat(9,GF(q))]));
        #  get power of G.3 with determinant 1
    else
        gens := GeneratorsOfGroup(G);
        return GroupByGenerators([gens[1],gens[2],gens[3]^(DeterminantMat(gens[3])),gens[4]]);
    fi;
end);


BindGlobal("l3qdim10",
function(q,general)
    local A,G,M,MM,S,T,g3,isit,o,rt,tp,w;
    # Assert(1,CollectedFactors(q)[1][1] >= 5);
    w:=PrimitiveElement(GF(q));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(3,q)),[One(GF(q))* DiagonalMat([w,1,1])]));
    M:=GModuleByMats(G,GF(q));
    # Magma T:=TensorPower(M,3); Correct GAP Code?
    T := TensorProductGModule(TensorProductGModule(M,M),M);
    MM:= Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    G:=Group(MTX.Generators(MM));
    if general then
        return Group(Concatenation(GeneratorsOfGroup(G),[w*IdentityMat(10,GF(q))]));
    fi;
    #  get intersection with SL
    o:=Order(DeterminantMat(GeneratorsOfGroup(G)[3]));
    
    # Transform into GAP Code
    #tp:=3^Valuation(o,3);
    tp := 1;
    #####
    
    g3:=GeneratorsOfGroup(G)[3]^(QuoInt(o,tp));
    # =v= MULTIASSIGN =v=
    
    # Transform into GAP Code
    # rt:=IsPower(DeterminantMat(g3),10);
    # isit:=rt.val1;
    # rt:=rt.val2;
    # Assert(1,isit);
    rt := 1;
    #####
    
    g3:=g3*(rt^-1*IdentityMat(10,GF(q)));
    S:=w^(QuoInt((q-1),Gcd(10,q-1)))*IdentityMat(10,GF(q));
    return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3,S]);
end);


BindGlobal("u3qdim10",
function(q,general,normaliser)
    local A,G,M,MM,S,T,g3,isit,o,rt,tp,w;
    # Assert(1,CollectedFactors(q)[1][1] >= 5);
    if normaliser then
        general:=true;
    fi;
    w:=PrimitiveElement(GF(q^2));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SU(3,q)),GeneratorsOfGroup(GU(3,q))[1]));
    M:=GModuleByMats(G,GF(q^2));
    # T:=TensorPower(M,3);
    T := TensorProductGModule(TensorProductGModule(M,M),M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    A:=Group(MTX.Generators(MM));
    G:=ConjugateToStandardForm(A,"U");
    if normaliser then
        return Group(Concatenation(GeneratorsOfGroup(G),[w*IdentityMat(10,GF(q^2))]));
    fi;
    if general then
        return Group(Concatenation(GeneratorsOfGroup(G),[w^(q-1)*IdentityMat(10,GF(q))]));
    fi;
    #  get intersection with SU
    o:=Order(DeterminantMat(GeneratorsOfGroup(G)[3]));
    
    # How to do this in GAP?
    # tp:=3^Valuation(o,3);
    
    tp := 1;
    g3:=GeneratorsOfGroup[3]^(QuoInt(o,tp));
    
    # How to do this in GAP?
    # =v= MULTIASSIGN =v=
    # rt:=IsPower(DeterminantMat(g3),10*(q-1));
    # isit:=rt.val1;
    # rt:=rt.val2;
    # Assert(1,isit);
    rt := 1;
    
    g3:=g3*(rt^-(q-1)*IdentityMat(10,GF(q^2)));
    S:=(w^(q-1))^(QuoInt((q+1),Gcd(10,q+1)))*IdentityMat(10,GF(q^2));
    return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3,S]);
end);


BindGlobal("l4qdim10",
function(q,general)
    local A,G,M,MM,S,T,g3,isit,o,rt,tp,w;
    # Assert(1,CollectedFactors(q)[1][1] >= 3);
    w:=PrimitiveElement(GF(q));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SL(4,q)),[One(GF(q))* DiagonalMat([w,1,1,1])]));
    M:=GModuleByMats(G,GF(q));
    # Magma T:=TensorPower(M,2);
    T := TensorProductGModule(M,M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    G:=Group(MTX.Generators(MM));
    if general then
        return Group(Concatenation(GeneratorsOfGroup(G),[w*IdentityMat(10,GF(q))]));
    fi;
    #  get intersection with SL
    o:=Order(DeterminantMat(GeneratorsOfGroup(G)[3]));
    
    # Magma tp:=2^Valuation(o,2);
    tp := 1;
    
    g3:=GeneratorsOfGroup(G)[3]^(QuoInt(2*o,tp));
    
    # How to do this in Magma
    # =v= MULTIASSIGN =v=
    # rt:=IsPower(DeterminantMat(g3),10);
    # isit:=rt.val1;
    # rt:=rt.val2;
    # Assert(1,isit);
    rt := 1;
    
    g3:=g3*((rt^-1)*IdentityMat(10,GF(q)));
    S:=w^(QuoInt((q-1),Gcd(10,q-1)))*IdentityMat(10,GF(q));
    return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3,S]);
end);


BindGlobal("u4qdim10",
function(q,general,normaliser)
    local A,G,M,MM,S,T,g3,isit,o,rt,tp,w;
    # Assert(1,CollectedFactors(q)[1][1] >= 3);
    if normaliser then
        general:=true;
    fi;
    w:=PrimitiveElement(GF(q^2));
    G:=GroupByGenerators(Concatenation(GeneratorsOfGroup(SU(4,q)),GeneratorsOfGroup(GU(4,q))[1]));
    M:=GModuleByMats(G,GF(q^2));
    # Magma T:=TensorPower(M,2);
    T := TensorProductGModule(M,M);
    MM:=Filtered(MTX.CompositionFactors(T),c->MTX.Dimension(c) = 10)[1];
    A:=Group(MTX.Generators(MM));
    G:=ConjugateToStandardForm(A,"U");
    if normaliser then
        return Group(Concatenation(GeneratorsOfGroup(G),[w*IdentityMat(10,GF(q^2))]));
    fi;
    if general then
        return Group(Concatenation(GeneratorsOfGroup(G),[w^(q-1)*IdentityMat(10,GF(q^2))]));
    fi;
    #  get intersection with SU
    o:=Order(DeterminantMat(GeneratorsOfGroup(G)[3]));
    
    # Magma tp:=2^Valuation(o,2);
    tp := 1;
    
    g3:=GeneratorsOfGroup(G)[3]^(QuoInt(2*o,tp));
    
    # How to do this in Magma
    # =v= MULTIASSIGN =v=
    # rt:=IsPower(DeterminantMat(g3),10*(q-1));
    # isit:=rt.val1;
    # rt:=rt.val2;
    # Assert(1,isit);
    rt := 1;
    
    g3:=g3*((rt^-(q-1))*IdentityMat(10,GF(q^2)));
    S:=(w^(q-1))^(QuoInt((q+1),Gcd(10,q+1)))*IdentityMat(10,GF(q^2));
    return GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3,S]);
end);


BindGlobal("sp4qdim10",
function(q,special,general,normaliser)
    #  /out:Sp4q <= O^+(10,q) (q=1 mod 4) or O^-(10,q) (q=3 mod 4)
    local C,G,M,M10,form,g3,isit,rt,scal,sign,tform,w,MG;
    Assert(1,IsOddInt(q));
    w:=PrimitiveElement(GF(q));
    
    # Magma
    # G:=SubStructure(GL(4,q),SP(4,q),NormSpMinusSp@(4,q));
    G := Sp(4,q);  #See line above
    
    M:=GModuleByMats(G,GF(q));
    C:=MTX.CompositionFactors(TensorProductGModule(M,M));
    M10:=Filtered(C,c->MTX.Dimension(c) = 10)[1];
    G:=Group(MTX.Generators(M10));
    
    # MAGMA      G:=G^TransformForm(SubStructure(G,G.1,#TODO CLOSURE G.2));
    # Write a function to realise this in GAP
    MG := GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2]]);
    G:=ConjugateToStandardForm(G,"L");
    
    # TODO: How to do this in GAP?
    #  adjust G.3 to fix form and G.4 to have determinant 1
    # =v= MULTIASSIGN =v=
    # form:=SymmetricBilinearForm(SubStructure(G,G.1,#TODO CLOSURE G.2));
    # isit:=form.val1;
    # form:=form.val2;
    # =^= MULTIASSIGN =^=
    # Assert(1,isit);
    # tform:=G.3*form*TransposedMat(G.3);
    # scal:=form[1][10]/tform[1][10];
    # =v= MULTIASSIGN =v=
    # rt:=IsPower(scal,2);
    # isit:=rt.val1;
    # rt:=rt.val2;
    # =^= MULTIASSIGN =^=
    # Assert(1,isit);
    # g3:=G.3*ScalarMat(9,rt);
    # rewritten select statement
    rt := 1;
    
    g3:=GeneratorsOfGroup(G)[3]*(rt*IdentityMat(10,GF(q)));
    G:=GroupByGenerators([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],g3]);
    # rewritten select statement
    if q mod 4=1 then
        sign:=1;
    else
        sign:=-1;
    fi;
    Assert(1,DeterminantMat(g3)=1 and not(g3 in Omega(sign,10,q)));
    if normaliser then
        return Group(Concatenation(GeneratorsOfGroup(G),w*IdentityMat(10,GF(q))));
    elif special or general then
        return Group(Concatenation(GeneratorsOfGroup(G),-1*IdentityMat(10,GF(q))));
    else
        return Group([GeneratorsOfGroup(G)[1],GeneratorsOfGroup(G)[2],-1*IdentityMat(10,GF(q))]);
    fi;
end);

