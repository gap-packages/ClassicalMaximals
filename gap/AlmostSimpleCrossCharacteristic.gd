#! @Chapter Maximal Subgroups of Classical Groups
#! @Section Groups in Class S: cross characteristic
#! @Arguments LR, q : special := false, general := false, normaliser := false
#! @Returns
#!  A list of matrix groups over $\mathrm{GF}(q)$, one for each orbit of irreducible
#!  constituents under the induced automorphism action.
#! @Description
#!  Let <A>LR</A> be a lattice record encoding an integral representation of a finite
#!  irreducible quasisimple group together with specified automorphisms.
#!  This function reduces that representation modulo a prime power <A>q</A>,
#!  analyses the resulting modular representation, and constructs associated
#!  subgroups of finite classical groups.
#!
#!  More precisely, the input record <A>LR</A> is assumed to have the following
#!  components:
#!  * <C>LR.G</C>: a finite irreducible quasisimple matrix group generated by two
#!    matrices over the integers.
#!  * <C>LR.F</C>: a free group of rank 2, used to encode automorphisms via words in
#!    the generators.
#!  * <C>LR.AI</C>: a list of automorphisms of <C>LR.G</C>, each given by the images of
#!    the two free word generators as words in <C>LR.F</C>.
#!
#!  The function proceeds as follows:
#!  First, the generators of <C>LR.G</C> are reduced modulo <A>q</A>, yielding a matrix
#!  group over $\mathrm{GF}(q)$ and the corresponding $\mathrm{GF}(q)$-module.
#!  The module is decomposed into its absolutely irreducible constituents.
#!  Trivial one-dimensional constituents are discarded.
#!
#!  Next, the automorphisms in <C>LR.AI</C> are applied to each irreducible
#!  constituent via their action on the two generators.
#!  This determines how the automorphisms permute the isomorphism classes of
#!  constituents; any new constituents arising in this process are added. In this way
#!  one obtains a permutation action of the given automorphisms on the set of
#!  constituents, and the orbits of this action are computed.
#!
#!  For each orbit, a representative constituent is chosen. The image of <C>LR.G</C>
#!  on this constituent is then extended by those automorphisms that stabilise the
#!  constituent up to isomorphism. For each such stabilising automorphism, an
#!  explicit isomorphism between the corresponding modules is computed (and adjusted
#!  by scalars so that it satisfies determinant and/or form conditions).
#!  According to the type of invariant form preserved by the module (linear, unitary,
#!  symplectic or orthogonal), the resulting group is realised as a subgroup of the
#!  corresponding finite classical group.
#!
#!  The optional flags modify the construction as follows:
#!  * if <C>special = true</C> (orthogonal case only), the normaliser in the special
#!    orthogonal group $\mathrm{SO}$ is constructed.
#!  * if <C>general = true</C> (linear, unitary or orthogonal cases), the normaliser
#!    in the full general group $\mathrm{GL}$, $\mathrm{GU}$ or $\mathrm{GO}$,
#!    respectively, is constructed.
#!  * if <C>normaliser = true</C> (symplectic, unitary or orthogonal cases), the
#!    normaliser in $\mathrm{GL}$ is constructed.
#!
#!  It is guaranteed that the returned groups respect the standard form used in this
#!  package, except when <C>normaliser = true</C>. In that case, preservation of a
#!  standard form ("up to scalars") is not ensured.
#!
#! @BeginExampleSession
#! gap> LR := rec();;
#! gap> LR.F := FreeGroup(2);; a := LR.F.1;; b := LR.F.2;;
#! gap> LR.AI := [ [a^-1, a*b*b*a*b*a*b*b] ];;
#! gap> LR.G := Group( [
#! >      [ [   0,  -1,   1,   0,  -1,  -1,   1,   0 ],
#! >        [   1,   0,  -1,   0,   1,  -1,  -1,   0 ],
#! >        [   0,   0,   0,   1,   0,  -1,   0,   0 ],
#! >        [   0,   0,   0,   0,  -1,   0,   1,   0 ],
#! >        [   0,  -1,   1,   1,   0,  -1,   0,   1 ],
#! >        [   0,   0,   1,   0,  -1,   0,   1,   0 ],
#! >        [   0,  -1,   1,   0,   0,  -1,   0,   1 ],
#! >        [   1,   0,   0,  -1,   0,   0,  -1,   0 ] ],
#! >      [ [   0,   0,   0,   0,  -1,   0,   0,   0 ],
#! >        [   0,  -1,   0,   1,   1,  -1,  -1,   1 ],
#! >        [   1,   0,  -1,   0,   0,   0,  -1,   0 ],
#! >        [   0,   0,   0,  -1,  -1,   1,   0,   0 ],
#! >        [   1,   0,   0,   0,  -1,   0,   0,   0 ],
#! >        [   1,   0,   0,  -1,  -1,   0,   0,   0 ],
#! >        [   0,   0,   1,   0,  -1,   0,   0,   0 ],
#! >        [   0,  -1,   1,   0,   0,  -1,   0,   0 ] ]
#! >    ] );;
#! gap> ModularReductionOfIntegralLattice(LR, 11);
#! [ <matrix group with 2 generators> ]
#! @EndExampleSession
DeclareGlobalFunction("ModularReductionOfIntegralLattice");
